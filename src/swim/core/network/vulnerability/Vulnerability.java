package swim.core.network.vulnerability;

/**Storage for link vulnerability factors
 * @author Saleh
 *
 */
public class Vulnerability{

	public int linkId;
	
	public double numberOfAlternatives;
	public double effectOnMaxFlow;
	public double effectOnTravelTime;
	
	public Vulnerability(int linkId, double numberOfAlternatives, double effectOnMaxFlow, double effectOnTravelTime){
		this.linkId = linkId;
		this.numberOfAlternatives = numberOfAlternatives;
		this.effectOnMaxFlow = effectOnMaxFlow;
		this.effectOnTravelTime = effectOnTravelTime;
	}
	
	public int getLinkId(){
		return linkId;
	}
	
	
	/**Compares link vulnerability based on a weighted sum of the following risk factors
	 * 1) number of alternative paths
	 * 2) effect on max flow
	 * 3) effect on shortest travel time
	 * @author Saleh
	 *
	 */
	public class Comparator implements java.util.Comparator<Vulnerability>{
		public double numberOfAlternativesWeight;
		public double effectOnMaxFlowWeight;
		public double effectOnTravelTimeWeight;
		
		/**Initialize the comparator setting the weights of the different risk factors
		 * @param numberOfAlternativesWeight
		 * @param effectOnMaxFlowWeight
		 * @param effectOnTravelTimeWeight
		 */
		public Comparator(
				double numberOfAlternativesWeight, double effectOnMaxFlowWeight, 
				double effectOnTravelTimeWeight){
			this.numberOfAlternativesWeight = numberOfAlternativesWeight;
			this.effectOnMaxFlowWeight = effectOnMaxFlowWeight;
			this.effectOnTravelTimeWeight = effectOnTravelTimeWeight;
		}
		
		@Override
		public int compare(Vulnerability arg0, Vulnerability arg1) {
			double result = 
					((-this.numberOfAlternativesWeight*
							(arg0.numberOfAlternatives-arg1.numberOfAlternatives))
					+(this.effectOnMaxFlowWeight*
							(arg0.effectOnMaxFlow-arg1.effectOnMaxFlow))
					+(this.effectOnTravelTimeWeight*
							(arg0.effectOnTravelTime-arg1.effectOnTravelTime)));
			if(result>0.0)
				return -1;
			else if(result<0.0)
				return 1;
			else
				return 0;
		}		
	}
	/*
		public void makeMaxFlowAlgorithm(ODPair od, Transformer<Integer,Number> capacityTransformer){
			
	    	class EdgeFactory implements Factory<Integer>{
	    		Iterator<Integer> linkId;
	    		int nextEdge;
	    		public EdgeFactory(){
	    			linkId = links.iterator();
	    		}
	
				@Override
				public Integer create() {
					if(linkId.hasNext()){
						nextEdge = linkId.next();
						return nextEdge;
					}else{
						return ++nextEdge;
					}
				}
	    		
	    	}
	    	
	    	flowMap = new HashMap<Integer,Number>();
	    	
	    	maxFlowAlgorithm = 
	    		new EdmondsKarpMaxFlow<Integer, Integer>(
	    				graph, od.getOrigin(), od.getDestination(), 
	    				capacityTransformer , 
	    				flowMap, new EdgeFactory());
		}
	
		public int[] getNumberOfAlternativesForEachLink(Path path){
			
			int[] result = new int[path.getPathLength()];
			
			ODPair od = path.getODPair();
			
	    	class AlternativeCapacityTransformer implements Transformer<Integer,Number>{
	    		public int linkBeingTested;
	    		
				@Override
				public Number transform(Integer arg0) {
					if(arg0==linkBeingTested){
						return 0;
					}
					else if(links.contains(arg0)){
						return 1;
					}
					else{
						return null;
					}
				}
	    	}
	    	
	    	AlternativeCapacityTransformer capacityTransformer = 
	    		new AlternativeCapacityTransformer();
	    	
	    	makeMaxFlowAlgorithm(od, capacityTransformer);
	    	
	    	int i=0;
	    	for(int l: path){
	    		capacityTransformer.linkBeingTested = l;
	        	maxFlowAlgorithm.evaluate();
	    		result[i++] = maxFlowAlgorithm.getMaxFlow(); 
	    	}
	    	
	    	return result;
		}
		
		public double[] getEffectOnMaxFlowForEachLink(final Map.Entry<Path, Double> assignment){
			
			Path path = assignment.getKey();
			
			//The result is an array, with one element for each link on the path of the assignment being evaluated
			double[] result = new double[path.getPathLength()];
	
			//Get the O-D Pair
			ODPair od = path.getODPair();
			
			//Provides the link capacities to the max-flow algorithm
	    	class AlternativeCapacityTransformer implements Transformer<Integer,Number>{
	    		
	    		private Path path;
	    		
	    		public int linkBeingTested;
	    			    		
	    		public AlternativeCapacityTransformer(Path path){
	    			this.path = path;
	    		}
	    		
				@Override
				//Capacity of linkBeingTested = 0
				//Capacity of other links of the assignment path = its residualCapacity + the assignment volume
				//Capacity of links that are not part of the assignment path = residualCapacity
				//Capacity of links when there is no assignment = residual capacity (why?)
				public Number transform(Integer linkId) {
					if(linkId==linkBeingTested){
						return 0;
					}
					else if(links.contains(linkId)){
						if(path==null){
							return links.getResidualCapacity(linkId);
						}
						else if(path.containsLink(linkId)){
							return links.getResidualCapacity(linkId)
								+assignment.getValue();
						}
						else{
							return links.getResidualCapacity(linkId);
						}
					}
					else{
						return null;
					}
				}
	    	}
	    	
	    	AlternativeCapacityTransformer originalMaxFlowTransformer = 
	    		new AlternativeCapacityTransformer(null);	//capacity with no assignment = residual capacity only
	    	
	    	originalMaxFlowTransformer.linkBeingTested = -1;	//no link being tested, i.e. all links are up
	    	
	    	makeMaxFlowAlgorithm(od, originalMaxFlowTransformer); //get the maximum additional flow the residual network can afford 
	    	maxFlowAlgorithm.evaluate();
	    	
	    	//The true maximum flow should be the sum of the max residual flow plus the original o-d flow
	    	//TODO: make original flow = sum of all assignment volumes from O to D
	    	double originalMaxFlow = demand.get(od) 
	    							+ maxFlowAlgorithm.getMaxFlow();
	    	    	
	    	AlternativeCapacityTransformer capacityTransformer =
	    						new AlternativeCapacityTransformer(path);    	
	    	
	    	makeMaxFlowAlgorithm(od, capacityTransformer);
	    	
	    	int i=0;
	    	for(int l: path){
	    		//The link to be disabled
	    		capacityTransformer.linkBeingTested = l;
	        	maxFlowAlgorithm.evaluate();
	        	
	        	//New max flow is the original demand - assignment volume + current residual max flow
	        	//Change in max flow is: original max flow - assignment rate
	    		result[i++] = (originalMaxFlow 
	    				- demand.get(od) + assignment.getValue() - maxFlowAlgorithm.getMaxFlow()); 
	    	}
	    	
	    	return result;
		}
		
		public double[] getEffectOnTravelTime(final Map.Entry<Path, Double> assignment){
			
			Path path = assignment.getKey();
			
			double[] result = new double[path.getPathLength()];
	
			ODPair od = path.getODPair();
			
	    	class AlternativeCapacityTransformer implements Transformer<Integer,Number>{
	    		public int linkBeingTested;
	    		private Path path;
	    		
	    		public AlternativeCapacityTransformer(Path path){
	    			this.path = path;
	    		}
	    		
				@Override
				public Number transform(Integer linkId) {
					if(linkId==linkBeingTested){
						return 0;
					}
					else if(links.contains(linkId)){
						if(path==null){
							return links.getResidualCapacity(linkId);
						}
						else if(path.containsLink(linkId)){
							return links.getResidualCapacity(linkId)
								+assignment.getValue();
						}
						else{
							return links.getResidualCapacity(linkId);
						}
					}
					else{
						return null;
					}
				}
	    	}
	    	
	    	AlternativeCapacityTransformer originalMaxFlowTransformer = 
	    		new AlternativeCapacityTransformer(null);    	
	    	originalMaxFlowTransformer.linkBeingTested = -1;
	    	makeMaxFlowAlgorithm(od, originalMaxFlowTransformer);
	    	maxFlowAlgorithm.evaluate();
	    	
	    	double originalTravelTime = 
	    		assignment.getValue() * path.getTravelTime() + 
	    		getMaxFlowTotalTravelTime();
	    	    	
	    	AlternativeCapacityTransformer capacityTransformer = 
	    		new AlternativeCapacityTransformer(path);    	
	    	
	    	makeMaxFlowAlgorithm(od, capacityTransformer);
	    	
	    	int i=0;
	    	for(int l: path){
	    		capacityTransformer.linkBeingTested = l;
	        	maxFlowAlgorithm.evaluate();
	
	        	double affectedTravelTime = 
	        		getMaxFlowTotalTravelTime();
	
	        	result[i++] = (originalTravelTime - affectedTravelTime); 
	    	}
	
	    	return result;
		}
		
		private double getMaxFlowTotalTravelTime(){
			double result = 0;
			for(Entry<Integer,Number> e : flowMap.entrySet()){
				int linkId = e.getKey();
				result += links.getTravelTime(linkId) * e.getValue().doubleValue();
			}
			return result;
		}
		
		Vulnerability[] getAllLinkVulnerabilities(){
			
			Vulnerability[] result = new Vulnerability[getLinkCount()];
			
			AveragingDouble.Map alternativesCount = new AveragingDouble.Map(getLinkCount());				
			AveragingDouble.Map effectOnMaxFlow = new AveragingDouble.Map(getLinkCount()); 		
			AveragingDouble.Map effectOnTravelTime = new AveragingDouble.Map(getLinkCount());
								
			//For each O-D pair
			for(Map.Entry<Path, Double> assignment: getAssignment()){
				Path path = assignment.getKey();
				int[] pathAlternativesCount = 
					getNumberOfAlternativesForEachLink(path);
				for(int i=0; i<path.getPathLength(); i++){
					alternativesCount.get(path.getPathLink(i))
					                  .add(pathAlternativesCount[i]);
				}
				
				double[] pathMaxFlowWithoutLink = 
					getEffectOnMaxFlowForEachLink(assignment);						
				for(int i=0; i<path.getPathLength(); i++){
					effectOnMaxFlow.get(path.getPathLink(i))
					                   .add(pathMaxFlowWithoutLink[i]);
				}
	
				double[] pathEffectOnTravelTime = 
					getEffectOnTravelTime(assignment);						
				for(int i=0; i<path.getPathLength(); i++){
					effectOnTravelTime.get(path.getPathLink(i))
					                   .add(pathEffectOnTravelTime[i]);
				}
			}
			int i=0;
	  		for(int l:links){  			
				result[i++] = new Vulnerability(l,
						alternativesCount.get(l).getValue(),
						effectOnMaxFlow.get(l).getValue(),
						effectOnTravelTime.get(l).getValue());
			}
			return result;		
		}

	 */
}	
