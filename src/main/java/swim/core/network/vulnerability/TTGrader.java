package swim.core.network.vulnerability;

import java.io.PrintStream;

import swim.core.network.Demand;
import swim.core.network.Network;
import swim.core.network.UWSensorNetwork;
import swim.core.network.Assignment;
import swim.core.network.Assignment.*;
import swim.core.network.algorithm.*;
import swim.core.network.misc.DoublePropertyMap;
import swim.core.network.misc.ReadOnlyProperty;
import swim.core.network.misc.ScaledProperty;

/**
 * @author Saleh Ibrahim
 *
 */
public abstract class TTGrader implements Grader {

	boolean reportAssignment = false,
		reportTravelTime = false,
		reportFlow = false,
		reportRuntime = false;
	
	boolean rerouteAll = false;

	PrintStream out;

	UWSensorNetwork network;
	Demand demand;
	
	Router router, rerouter;	
	Assignment baseAssignment;
	
	long runtime;

	protected ScaledProperty disruptable;

	private ReadOnlyProperty<Double> oldFreeFlowTravelTime;
	
	private ReadOnlyProperty<Double> grades;
	
	private double totalAssigned;

	private double totalDemand;

	private double baseTotalTravelTime;
	
	private Assignment reassignment; 
	
	public TTGrader(PrintStream out){
		this.out = out;
	}	

	private class DelayedResult extends ReadOnlyProperty<Double>{
		
		private DoublePropertyMap result;

		public DelayedResult() {
			super("link", TTGrader.this.getTitle(), TTGrader.this.network, 0.0);
			result = new DoublePropertyMap(getTitle().concat("-inner"), network, null);
		}

		@Override
		public ReadOnlyProperty<Double> clone(Network network) {
			return this;
		}

		@Override
		public Double get(int linkId) {
			if(result.get(linkId)==null){
				result.set(linkId, gradeLink(linkId));
			}
			return result.get(linkId);
		}
		
	}

	private void initGrade(UWSensorNetwork network, Demand demand){
		
		
		this.network = network;
		this.demand = demand;
		
		totalDemand = demand.getTotal();

		beginGrade();
		
		createRouters();
		
		route();
		
		totalAssigned = baseAssignment.getTotal();
		
		if(Math.abs(totalDemand-totalAssigned)>1e-6*totalDemand){
			System.err.printf("Base routing unsuccessful. Total assigned (%f) less than total demand (%f)\n", 
					totalAssigned, totalDemand);
		}
		
		if(reportAssignment && out!=null){
			out.print("Base Assignment\n");
			out.printf("%s\n", baseAssignment.toString());
		}
		
		baseTotalTravelTime = calculateAssignmentTravelTime(baseAssignment);
		
		if(reportTravelTime && out!=null) {
			out.printf("Base total travel time = %f\n", baseTotalTravelTime);
		}
		
		if(reportFlow && out!=null) {
			out.printf("Base network flow:\n%s\n", network.getFlow().toString());
		}		
	}
	
	private double gradeLink(int linkId){
		
		disruptable.disrupt(linkId, 10.0);
		
		reassignment = reroute();
		
		totalAssigned = reassignment.getTotal();
		
		if(Math.abs(totalDemand-totalAssigned)>1e-6*totalDemand){
			System.err.printf("Rerouting without link %d unsuccessful. Total assigned (%f) less than total demand (%f)\n", 
					linkId, totalAssigned, totalDemand);
		}

		if(reportAssignment && out!=null){
			out.printf("Assignment without #%d\n", linkId);
			out.printf("%s\n", reassignment.toString());
		}
		
		double totalTravelTime = this.calculateAssignmentTravelTime(reassignment);
		double travelTimeRelativeIncrease = 100* (totalTravelTime - baseTotalTravelTime)/baseTotalTravelTime;
		
		if(reportTravelTime && out!=null){
			out.printf("\nTotal travel time without link #%d = %f, Relative Increase = %f\n", linkId, totalTravelTime, travelTimeRelativeIncrease);
		}

		if(reportFlow && out!=null) {
			out.printf("Network flow without link #%d:\n%s", linkId, network.getFlow().toString());
		}

		return travelTimeRelativeIncrease;
	}
	
	/* (non-Javadoc)
	 * @see tn.vulnerability.Grader#Grade(tn.Network, tn.Network.Demand)
	 */
	@Override
	public ReadOnlyProperty<Double> grade(UWSensorNetwork network, Demand demand){
		
		runtime = System.currentTimeMillis();

		initGrade(network, demand);

		DoublePropertyMap grades = 
			new DoublePropertyMap("link", this.getTitle(), network);
				
		for(Integer link: network.getLinks()){
			
			grades.set(link, gradeLink(link));

			//network.resetFlow();
			disruptable.reset(link);
		}
		
		runtime = System.currentTimeMillis()-runtime;

		if(reportRuntime && out!=null) {
			out.printf("Runtime =%f ms\n", runtime);
		}
		
		endGrade();

		this.grades = grades;
		
		return grades;
	}
	
	public ReadOnlyProperty<Double> delayedGrade(UWSensorNetwork network, Demand demand){
		initGrade(network, demand);

		return grades = new DelayedResult();
	}

	protected void beginGrade() {

		oldFreeFlowTravelTime = network.getFreeFlowTravelTime();

		disruptable = new ScaledProperty("link", oldFreeFlowTravelTime);
		
		network.setFreeFlowTravelTime(disruptable);
		
	}
	
	/** calculate the initial assignment for the entire volume of the demand
	 * The demand to be routed is stored in the {@link demand} attribute.
	 * Stores the initial assignment in the {@link baseAssignment} attribute.
	 */
	void route(){
		
		baseAssignment = router.route(demand);
		
		network.loadAssignment(baseAssignment);
		
	}
	
	/** calculate the new assignment after some of the links have been disabled
	 * the total demand to be routed is stored in the {@link demand} attribute 
	 * @return New assignment 
	 */
	Assignment reroute(){
	
		Assignment reassignment;
		
		if(rerouteAll){
			
			reassignment = rerouter.route(demand);
			
		}
		else{
			
			AssignmentFilterResult assignments
						= baseAssignment.filterByLink(disruptable.getScaledLinks());
	
			reassignment = assignments.excluded;
			
			reassignment.add(rerouter.route(assignments.included.toDemand()));			
		}
		
		network.loadAssignment(reassignment);
		
		return reassignment;		
	}

	protected void endGrade() {

		network.setFreeFlowTravelTime(oldFreeFlowTravelTime);

	}

	@Override
	public long getRuntimeMillis(){
		return runtime;
	}


	protected double calculateAssignmentTravelTime( Assignment a){
		DoublePropertyMap oldFlow = network.resetFlow(a.getFlow()); 
		
		double result = network.getTotalTravelCost().getSum();
		
		network.setFlow(oldFlow);
		return result;		
	}
	
		
	@Override
	public String getTitle() {
		return "FFTT";
	}

	/**
	 * @param linkId 
	 * @return travel time of the given link under current assignment and assumptions
	 */
	double getLinkTravelTime(int linkId){
		return network.getTravelTime(linkId);
	}
	
	/**Create the initial router {@link router} and rerouter {@link rerouter}
	 * 
	 */
	protected abstract void createRouters();

	public ReadOnlyProperty<Double> getGrades() {
		return grades;
	}
	
	public Assignment getBaseAssignment(){
		return baseAssignment;
	}
	
	public Assignment getReassignment(){
		return reassignment;
	}
}
